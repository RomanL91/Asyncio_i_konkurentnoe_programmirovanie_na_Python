# 2.7 Ловушки сопрограмм и задач

# Увидев, какой выигрыш может дать конкурентное выполнение дли
# тельных задач, мы можем поддаться искушению использовать сопрограммы
# и задачи всюду и везде. Но просто снабдить функции
# ключевым словом async и обернуть их задачами может оказаться недостаточно
# для повышения производительности. А в некоторых случаях 
# производительность может даже упасть.
# Есть две основные ошибки на пути преобразования приложения
# в асинхронное. Первая – попытка выполнить счетный код в задачах
# или сопрограммах, не прибегая к многопроцессности, вторая – использовать 
# блокирующие API ввода-вывода, пренебрегая многопоточностью.

    # Листинг 2.18 Попытка конкурентного выполнения счетного кода

import asyncio
from part_2_3 import delay
from part_2_6 import async_timed


@async_timed()
async def cpu_bound_work() -> int:
    counter = 0
    for i in range(100000000):
        counter = counter + 1
    return counter


@async_timed()
async def main():
    task_one = asyncio.create_task(cpu_bound_work())
    task_two = asyncio.create_task(cpu_bound_work())
    await task_one
    await task_two


# asyncio.run(main())

# Глядя на этот результат, мы можем подумать, что нет ничего плохого 
# в том, чтобы повсюду расставить async и await. В конце концов,
# времени-то уходит столько же, сколько при последовательном выполнении. 
# Однако при таком подходе мы можем оказаться в ситуации, 
# когда производительность приложения падает.

    # Листинг 2.19 Счетный код и длительная задача

@async_timed()
async def cpu_bound_work() -> int:
    counter = 0
    for i in range(100000000):
        counter = counter + 1
    return counter


@async_timed()
async def main():
    task_one = asyncio.create_task(cpu_bound_work())
    task_two = asyncio.create_task(cpu_bound_work())
    delay_task = asyncio.create_task(delay(4))
    await task_one
    await task_two
    await delay_task


# asyncio.run(main())

# Кажется, что эта программа должна работать столько же, сколько
# программа в листинге 2.18. Разве delay_task не будет выполняться
# конкурентно со счетными задачами? Нет, не будет, потому что мы
# сначала создали две счетные задачи и тем самым не даем циклу событий
# выполнить что-то еще. Следовательно, время работы приложения
# будет равно сумме времен работы задач cpu_bound_work плюс
# 4 с, которые займет задача delay.
# Если требуется выполнить счетную работу и все-таки использовать
# async / await, то это можно сделать. Но придется воспользоваться
# многопроцессностью и попросить asyncio выполнять наши задачи
# в пуле процессов. Как это сделать, мы узнаем в главе 6.


# 2.7.2 Выполнение блокирующих API

# Может возникнуть соблазн использовать существующие библиотеки
# ввода-вывода, обернув их сопрограммами. Однако при этом возникнут
# те же проблемы, что для счетных операций. Эти API будут блокировать
# главный поток. Поэтому, попытавшись выполнить блокирующий
# вызов API в сопрограмме, мы заблокируем сам поток цикла событий,
# а значит, воспрепятствуем выполнению всех остальных сопрограмм
# и задач. Примерами блокирующих API является библиотека requests
# или функция time.sleep. Вообще, любая функция, которая выполняет
# ввод-вывод, не являясь сопрограммой, или занимает процессор длительными
# операциями, может считаться блокирующей.

    # Листинг 2.20 Неправильное использование блокирующего API как сопрограммы

import requests

@async_timed()
async def get_example_status() -> int:
    return requests.get('http://www.google.com').status_code


@async_timed()
async def main_get_example_status():
    task_1 = asyncio.create_task(get_example_status())
    task_2 = asyncio.create_task(get_example_status())
    task_3 = asyncio.create_task(get_example_status())
    await task_1
    await task_2
    await task_3


asyncio.run(main_get_example_status())

# И снова причина в том, что библиотека requests блокирующая, т. е.
# блокирует поток, в котором выполняется. Поскольку asyncio однопоточная,
# библиотека requests блокирует цикл событий и не дает ничему
# выполняться конкурентно.

# В примере выше мы могли бы использовать библиотеку aiohttp,
# в которой используются неблокирующие сокеты и которая возвращает
# сопрограммы, тогда с конкурентностью все было бы нормально.

# Если вы все-таки хотите использовать библиотеку requests, то синтаксис
# async применить можно, но нужно явно попросить asyncio задействовать
# многопоточность с по­мощью исполнителя пула потоков.



# к разбору далее
# 2.8
# Ручное управление циклом событий
