# 2.7 Ловушки сопрограмм и задач

# Увидев, какой выигрыш может дать конкурентное выполнение дли
# тельных задач, мы можем поддаться искушению использовать сопрограммы
# и задачи всюду и везде. Но просто снабдить функции
# ключевым словом async и обернуть их задачами может оказаться недостаточно
# для повышения производительности. А в некоторых случаях 
# производительность может даже упасть.
# Есть две основные ошибки на пути преобразования приложения
# в асинхронное. Первая – попытка выполнить счетный код в задачах
# или сопрограммах, не прибегая к многопроцессности, вторая – использовать 
# блокирующие API ввода-вывода, пренебрегая многопоточностью.

    # Листинг 2.18 Попытка конкурентного выполнения счетного кода

import asyncio
from part_2_3 import delay
from part_2_6 import async_timed


@async_timed()
async def cpu_bound_work() -> int:
    counter = 0
    for i in range(100000000):
        counter = counter + 1
    return counter


@async_timed()
async def main():
    task_one = asyncio.create_task(cpu_bound_work())
    task_two = asyncio.create_task(cpu_bound_work())
    await task_one
    await task_two


# asyncio.run(main())

# Глядя на этот результат, мы можем подумать, что нет ничего плохого 
# в том, чтобы повсюду расставить async и await. В конце концов,
# времени-то уходит столько же, сколько при последовательном выполнении. 
# Однако при таком подходе мы можем оказаться в ситуации, 
# когда производительность приложения падает.

    # Листинг 2.19 Счетный код и длительная задача

@async_timed()
async def cpu_bound_work() -> int:
    counter = 0
    for i in range(100000000):
        counter = counter + 1
    return counter


@async_timed()
async def main():
    task_one = asyncio.create_task(cpu_bound_work())
    task_two = asyncio.create_task(cpu_bound_work())
    delay_task = asyncio.create_task(delay(4))
    await task_one
    await task_two
    await delay_task


asyncio.run(main())

# Кажется, что эта программа должна работать столько же, сколько
# программа в листинге 2.18. Разве delay_task не будет выполняться
# конкурентно со счетными задачами? Нет, не будет, потому что мы
# сначала создали две счетные задачи и тем самым не даем циклу событий
# выполнить что-то еще. Следовательно, время работы приложения
# будет равно сумме времен работы задач cpu_bound_work плюс
# 4 с, которые займет задача delay.
# Если требуется выполнить счетную работу и все-таки использовать
# async / await, то это можно сделать. Но придется воспользоваться
# многопроцессностью и попросить asyncio выполнять наши задачи
# в пуле процессов. Как это сделать, мы узнаем в главе 6.




















