# ПРОБЛЕМА:
# Например, отправвляя запросы на сервер, мы должны следить следить за ними, 
# чтобы неждать слишком долго. Иначе, приложение можно зависнуть, ожидая резултата,
# который никогда не придет. 
# В рассмотренных ранее примерах (младшие части) если бы задачи рабоали вечно, то 
# мы бы застряли в предложении await без всякой обратной связи. И остановить программу 
# не смогли бы.

# 2.4.1 Снятие задачи
# Снять задачу просто. У каждого объекта задачи есть метод cancel, который можно вызвать, 
# если требуется остановить задачу. В результате снятия задача возбудит исключение
# CancelledError, когда мы ждем ее с по­мощью await. 
# Это исключения можно обработать, как того требует ситуация.

# Для иллюстрации предпожим, что мы запустили задачу, которая не дожна работать больше 
# 5 секунд. Если задача не выполнилась за это время, то мы ее снимаем. Так же хотим знать
# статус ее выполнения, например принтами.


import asyncio

from asyncio import CancelledError

from part_2_3 import delay


async def main_cancel():
    long_task = asyncio.create_task(delay(10)) # долгая задача 10 с
    seconds_elapsed = 0 # некий таймер
    
    while not long_task.done(): # мето
        print('Задача не закончилась, следующая проверка через секунду.')
        await asyncio.sleep(1) 
        seconds_elapsed = seconds_elapsed + 1 # увеличиваем таймер
        if seconds_elapsed == 5: # условие таймера
            long_task.cancel() # снимаем задачу
    try:
        await long_task
    except CancelledError:
        print('Наша задача была снята')


# Вызов cancel не прерывает задачу, делающую свое дело;
# он снимает ее, только если она уже находится в точке ожидания или
# когда дойдет до следующей такой точки. Это важно помнить и понимать так - 
# что вызов cancel как бы прикрепит к задаче статус CancelledError и если не 
# будет встречено await в последующем, то и задача не снимится.

# ===================================================================================
# 2.4.2 Задание тайм-аута и снятие с по­мощью wait_for

# ПРОБЛЕМА:
# Пример выше это некий показательный пример, в нем мы хардим таймаут задачи. 
# Хотелось бы иметь функцию, которой можно отдать обьект сопрограммы и указать таймаут для
# ее выполнения. Можно написать самому. Но есть готовый вариант.


async def main_wait_for():
    delay_task = asyncio.create_task(delay(2)) # задача в 2 с
    try:
        result = await asyncio.wait_for(delay_task, timeout=1) # таймаут в 1 сек
        print(result)
    except asyncio.exceptions.TimeoutError: # ожидаймое исключение
        print('Тайм-аут!')
        print(f'Задача была снята? {delay_task.cancelled()}') # статус отмены



if __name__ == "__main__":
    print('Выполняю функцию main_cancel')
    asyncio.run(main_cancel())
    print('='*80)
    print('Выполняю функцию main_wait_for')
    asyncio.run(main_wait_for())
