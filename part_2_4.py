# ПРОБЛЕМА:
# Например, отправвляя запросы на сервер, мы должны следить следить за ними, 
# чтобы неждать слишком долго. Иначе, приложение можно зависнуть, ожидая резултата,
# который никогда не придет. 
# В рассмотренных ранее примерах (младшие части) если бы задачи рабоали вечно, то 
# мы бы застряли в предложении await без всякой обратной связи. И остановить программу 
# не смогли бы.

# 2.4.1 Снятие задачи
# Снять задачу просто. У каждого объекта задачи есть метод cancel, который можно вызвать, 
# если требуется остановить задачу. В результате снятия задача возбудит исключение
# CancelledError, когда мы ждем ее с по­мощью await. 
# Это исключения можно обработать, как того требует ситуация.

# Для иллюстрации предпожим, что мы запустили задачу, которая не дожна работать больше 
# 5 секунд. Если задача не выполнилась за это время, то мы ее снимаем. Так же хотим знать
# статус ее выполнения, например принтами.


import asyncio

from asyncio import CancelledError

from part_2_3 import delay


async def main():
    long_task = asyncio.create_task(delay(10)) # долгая задача 10 с
    seconds_elapsed = 0 # некий таймер
    
    while not long_task.done(): # мето
        print('Задача не закончилась, следующая проверка через секунду.')
        await asyncio.sleep(1) 
        seconds_elapsed = seconds_elapsed + 1 # увеличиваем таймер
        if seconds_elapsed == 5: # условие таймера
            long_task.cancel() # снимаем задачу
    try:
        await long_task
    except CancelledError:
        print('Наша задача была снята')


asyncio.run(main())

# Вызов cancel не прерывает задачу, делающую свое дело;
# он снимает ее, только если она уже находится в точке ожидания или
# когда дойдет до следующей такой точки. Это важно помнить и понимать так - 
# что вызов cancel как бы прикрепит к задаче статус CancelledError и если не 
# будет встречено await в последующем, то и задача не снимится.
