# 6.5 Разделяемые данные и блокировки
# 
# В главе 1 мы говорили о том, что каждый процесс имеет собственную
# память, изолированную от памяти других процессов. Спрашивается,
# что делать, если нужно организовать общую память для хранения
# разделяемой несколькими процессами информации о состоянии?
# Библиотека multiprocessing поддерживает так называемые объекты
# разделяемой памяти. Это блок памяти, выделенный так, что к нему
# могут обращаться разные процессы.

# ==================================================================

from multiprocessing import Process, Value, Array


def increment_value(shared_int: Value): # type: ignore
    shared_int.value = shared_int.value + 1


def increment_array(shared_array: Array): # type: ignore
    for index, integer in enumerate(shared_array):
        shared_array[index] = integer + 1


# if __name__ == '__main__':
#     integer = Value('i', 0)
#     integer_array = Array('i', [0, 0])

#     procs = [Process(target=increment_value, args=(integer,)),
#     Process(target=increment_array, args=(integer_array,))]

#     [p.start() for p in procs]
#     [p.join() for p in procs]
    
#     print(integer.value)
#     print(integer_array[:])

# ==================================================================
# ==================================================================
# Пример гонки
        
def increment_value(shared_int: Value): # type: ignore
    shared_int.value = shared_int.value + 1


# if __name__ == '__main__':
#     for _ in range(100):
#         integer = Value('i', 0)
#         procs = [Process(target=increment_value, args=(integer,)),
#                 Process(target=increment_value, args=(integer,))]

#         [p.start() for p in procs]
#         [p.join() for p in procs]

#         print(integer.value)
#         assert(integer.value == 2)


# 1
# Traceback (most recent call last):
#   File "/////////part_6_5.py", line 69, in <module>
#     assert(integer.value == 2)
# AssertionError
# ==================================================================
# ==================================================================

# Избежать гонки можно, синхронизировав доступ к тем разделяемым
# данным, которые мы собираемся модифицировать. Что под этим понимается? 
# Это значит, что мы управляем доступом к разделяемым
# данным таким образом, чтобы все операции финишировали в осмысленном порядке. 
# Если возможна ничья между какими-то двумя операциями, то мы явно блокируем 
# вторую до завершения первой, гарантируя тем самым, что операции финишируют так, как нужно.

# Один из механизмов для синхронизации доступа к разделяемым
# данным называется блокировкой, или мьютексом (от mutual exclusion –
# взаимное исключение). Он позволяет одному процессу заблокировать
# участок кода, т. е. запретить всем остальным его выполнение. Заблокированный 
# участок обычно называют критической секцией. Если один
# процесс выполняет код в критической секции, а второй пытаемся выполнить 
# тот же код, то второму придется подождать (арбитр не пускает его), 
# пока первый закончит работу и выйдет из критической секции.

# Блокировки поддерживают две основные операции: захват и освобождение. 
# Гарантируется, что процесс, захвативший блокировку, –
# единственный, кто может выполнять код в критической секции. Закончив 
# выполнение кода, требующего синхронизации доступа, мы
# освобождаем блокировку. Это дает возможность другим процессам
# захватить блокировку и выполнить код в критической секции. Если
# процесс попытается выполнить код в секции, заблокированной другим процессом, 
# то будет приостановлен, пока этот другой процесс не освободит блокировку.


# Попытка Процесса 2 прочитать разделяемые данные блокируется, пока
# Процесс 1 не освободит блокировку
    
# При выполнении этой программы мы всегда будем получать значение 2. 
# Гонка устранена! Заметим, что блокировки являются контекстными менеджерами, 
# и, чтобы сделать код чище, мы могли быиспользовать в функции increment_value 
# блок with. Тогда захвати осво­бождение блокировки будут производиться автоматически:
    
def increment_value(shared_int: Value): # type: ignore
    # shared_int.get_lock().acquire()
    # shared_int.value = shared_int.value + 1
    # shared_int.get_lock().release()
    with shared_int.get_lock():
        shared_int.value = shared_int.value + 1 


if __name__ == '__main__':
    for _ in range(100):
        integer = Value('i', 0)
        procs = [Process(target=increment_value, args=(integer,)),
                Process(target=increment_value, args=(integer,))]

    [p.start() for p in procs]
    [p.join() for p in procs]

    print(integer.value)
    assert (integer.value == 2)

# Обратите внимание, что мы принудительно преобразовали конкурентный код в 
# последовательный, сведя на нет преимущества распараллеливания. 
# Это важное наблюдение, поскольку проливает свет на недостаток 
# синхронизации и разделяемые данные вообще. Чтобы избежать гонки, код в 
# критических секциях обязан выполняться последовательно. 
# Это может отрицательно сказаться на производительности многопроцессного кода. 
# Поэтому нужно внимательно следить за тем, чтобы защищать блокировкой только то, 
# что абсолютно необходимо, и не мешать остальному коду выполняться конкурентно.
# Столкнувшись с состоянием гонки, не нужно идти по легкому пути
# и защищать блокировкой все вообще. Проблему-то вы решите, но,
# скорее всего, производительность сильно пострадает.

