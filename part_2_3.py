# Конспектирование.

# Типы многозодачности:
#     Вытесняющая
#         Тут мы позволяем операционной системе решить, как переключиться между
#         выполняемыми задачами с помощью процедуры квантования времени. При переключении
#         мы говорим, что имеет место вытеснеию. Как устроен этот механимз зависит от операцинной системы.
#     Кооперативная
#         Тут мы не пологаемся на операционную систему,  явно указываем в коде точки, где можно
#         устутпить управление другой задаче. Исполняемые задачи кооперируются.

# Преимущества кооперативной многозадачности:
    # отсутствие переключение контекста между потоками
    # сами помечаем в коде, где нужно остановить задачу и передать упавление
        # что может быть более эфективным по сравнению с алгоритмами системы


import asyncio


# Повторно используемуя программа
async def delay(delay_seconds: int) -> int:
    print(f'засыпаю на {delay_seconds} с')
    await asyncio.sleep(delay_seconds)
    print(f'сон в течение {delay_seconds} с закончился')
    return delay_seconds


async def hello_every_second():
    for i in range(9):
        await asyncio.sleep(1)
        print("пока я жду, исполняется другой код!")


async def main():
    sleep_for_three = asyncio.create_task(delay(3))
    sleep_again = asyncio.create_task(delay(5))
    sleep_once_more = asyncio.create_task(delay(7))
    await hello_every_second()
    await sleep_for_three
    await sleep_again
    await sleep_once_more


if __name__ == "__main__":
    asyncio.run(main())


# конкурентный запуск нескольких длительно выполняющихся задач
# каждое обращение к create_task поэтому до await доходим сразу же.
# await по сути запускает итерацию по циклю событий, где находятся
# задачи, которые создали выше и запускает их выполнение.
# 
# hello_every_second выполняем фоново, пока sleep в других сопрограммах отработает.
# 
# 
# к разбору далее
# 2.4 Снятие задач и задание тайм-аутов